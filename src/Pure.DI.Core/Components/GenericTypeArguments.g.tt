<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="netstandard" #>
<#@ import namespace="System.Collections.Generic" #>
// <auto-generated/>
#if !PUREDI_API_SUPPRESSION || PUREDI_API_V2
#pragma warning disable
namespace Pure.DI
{    
<#
var netTypes = new Dictionary<string, string> { 
    { "global::System.IDisposable", "TTDisposable#" },
    { "global::System.IComparable", "TTComparable#" },
    { "global::System.IComparable<T>", "TTComparable#<in T>" },
    { "global::System.IEquatable<T>", "TTEquatable#<T>" },
    { "global::System.Collections.Generic.IEnumerable<T>", "TTEnumerable#<out T>" },
    { "global::System.Collections.Generic.IEnumerator<T>", "TTEnumerator#<out T>" },
    { "global::System.Collections.Generic.ICollection<T>", "TTCollection#<T>" },
    { "global::System.Collections.Generic.IList<T>", "TTList#<T>" },
    { "global::System.Collections.Generic.ISet<T>", "TTSet#<T>" },
    { "global::System.Collections.Generic.IComparer<T>", "TTComparer#<in T>" },
    { "global::System.Collections.Generic.IEqualityComparer<T>", "TTEqualityComparer#<in T>" },
    { "global::System.Collections.Generic.IDictionary<TKey, TValue>", "TTDictionary#<TKey, TValue>" },
    { "global::System.IObservable<T>", "TTObservable#<out T>" },
    { "global::System.IObserver<T>", "TTObserver#<in T>" }
};

var net45Types = new Dictionary<string, string> { 
    { "global::System.Collections.Generic.IReadOnlyCollection<T>", "TTReadOnlyCollection#<out T>" },
    { "global::System.Collections.Generic.IReadOnlyList<T>", "TTReadOnlyList#<out T>" }
};

var netCoreTypes = new Dictionary<string, string> { 
    { "global::System.Collections.Immutable.IImmutableList<T>", "TTImmutableList#<T>" },
    { "global::System.Collections.Immutable.IImmutableSet<T>", "TTImmutableSet#<T>" },
    { "global::System.Collections.Immutable.IImmutableQueue<T>", "TTImmutableQueue#<T>" },
    { "global::System.Collections.Immutable.IImmutableStack<T>", "TTImmutableStack#<T>" }
};
#>
<#for(var i = 0; i <= 16; i++)
{
    var typeName = i == 0 ? "" : i.ToString();#>
    /// <summary>
    /// Marker for a reference type generic argument used in setup APIs.
    /// </summary>
    /// <example>
    /// <code>
    /// DI.Setup("Composition")
    ///     .Bind&lt;IDependency&lt;TT<#=typeName#>&gt;&gt;().To&lt;Dependency&lt;TT<#=typeName#>&gt;&gt;();
    /// </code>
    /// </example>
    [GenericTypeArgument]
#if !NET20 && !NET35 && !NETSTANDARD1_0 && !NETSTANDARD1_1 && !NETSTANDARD1_2 && !NETSTANDARD1_3 && !NETSTANDARD1_4 && !NETSTANDARD1_5 && !NETSTANDARD1_6 && !NETCOREAPP1_0 && !NETCOREAPP1_1
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif
    internal abstract class TT<#=typeName#> { }

    /// <summary>
    /// Marker for a reference type with a public parameterless constructor.
    /// </summary>
    /// <example>
    /// <code>
    /// DI.Setup("Composition")
    ///     .Bind&lt;IDependency&lt;TTN<#=typeName#>&gt;&gt;().To&lt;Dependency&lt;TTN<#=typeName#>&gt;&gt;();
    /// </code>
    /// </example>
    [GenericTypeArgument]
#if !NET20 && !NET35 && !NETSTANDARD1_0 && !NETSTANDARD1_1 && !NETSTANDARD1_2 && !NETSTANDARD1_3 && !NETSTANDARD1_4 && !NETSTANDARD1_5 && !NETSTANDARD1_6 && !NETCOREAPP1_0 && !NETCOREAPP1_1
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif
    internal class TTN<#=typeName#> { public TTN<#=typeName#>() {} }

    /// <summary>
    /// Marker for a value type generic argument.
    /// </summary>
    /// <example>
    /// <code>
    /// DI.Setup("Composition")
    ///     .Bind&lt;IDependency&lt;TTS<#=typeName#>&gt;&gt;().To&lt;Dependency&lt;TTS<#=typeName#>&gt;&gt;();
    /// </code>
    /// </example>
    [GenericTypeArgument]
#if !NET20 && !NET35 && !NETSTANDARD1_0 && !NETSTANDARD1_1 && !NETSTANDARD1_2 && !NETSTANDARD1_3 && !NETSTANDARD1_4 && !NETSTANDARD1_5 && !NETSTANDARD1_6 && !NETCOREAPP1_0 && !NETCOREAPP1_1
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
#endif
    internal struct TTS<#=typeName#> { }

    /// <summary>
    /// Marker for an enum generic argument.
    /// </summary>
    /// <example>
    /// <code>
    /// DI.Setup("Composition")
    ///     .Bind&lt;IDependency&lt;TTE<#=typeName#>&gt;&gt;().To&lt;Dependency&lt;TTE<#=typeName#>&gt;&gt;();
    /// </code>
    /// </example>
    [GenericTypeArgument]
    internal enum TTE<#=typeName#> { }

<#
    if (i > 8)
    {
        continue;
    }#>
#if !NET35 && !NET20
<#
    foreach(var type in netTypes)
    {
        typeName = type.Value.Replace("#", i == 0 ? "" : i.ToString());
        var commentTypeName = typeName.Replace("in ", "").Replace("out ", "").Replace("<T>", "&lt;TT&gt;");#>

    /// <summary>
    /// Marker that mirrors <see cref="<#=type.Key.Replace('<', '{').Replace('>', '}')#>"/> for setup-time generic arguments.
    /// </summary>
    /// <example>
    /// <code>
    /// DI.Setup("Composition")
    ///     .Bind&lt;IDependency&lt;<#=commentTypeName#>&gt;&gt;().To&lt;Dependency&lt;<#=commentTypeName#>&gt;&gt;();
    /// </code>
    /// </example>
    [GenericTypeArgument]
    internal interface <#=typeName#>: <#=type.Key#> { }
    <#}#>

#endif

#if NETSTANDARD || NET || NETCOREAPP || NET45_OR_GREATER
<#
    foreach(var type in net45Types)
    {#>

    /// <summary>
    /// Marker that mirrors <see cref="<#=type.Key.Replace('<', '{').Replace('>', '}')#>"/> for setup-time generic arguments.
    /// </summary>
    [GenericTypeArgument]
    internal interface <#=type.Value.Replace("#", i == 0 ? "" : i.ToString())#>: <#=type.Key#> { }
    <#}#>

#endif

#if NET || NETCOREAPP
<#
    foreach(var type in netCoreTypes)
    {#>

    /// <summary>
    /// Marker that mirrors <see cref="<#=type.Key.Replace('<', '{').Replace('>', '}')#>"/> for setup-time generic arguments.
    /// </summary>
    [GenericTypeArgument]
    internal interface <#=type.Value.Replace("#", i == 0 ? "" : i.ToString())#>: <#=type.Key#> { }
    <#}#>

#endif

<#}#>
}
#pragma warning restore
#endif
